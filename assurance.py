# -*- coding: utf-8 -*-
"""ASSURANCE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/bigirimanainnocent12/RandomForestRegressor/blob/main/ASSURANCE.ipynb

# ***À propos de l'ensemble de données***

**Présentation de l'ensemble de données :**

L'ensemble de données sur l'assurance maladie contient des informations sur plusieurs facteurs pouvant influencer les dépenses médicales, notamment l'âge, le sexe, l'IMC, le tabagisme, le nombre d'enfants et la région. Cet ensemble de données peut servir à former un modèle d'apprentissage automatique capable de prédire les dépenses médicales des nouveaux clients.

Fournir un aperçu des facteurs clés qui contribuent à l’augmentation des coûts d’assurance et aider l’entreprise à prendre des décisions plus éclairées en matière de tarification et d’évaluation des risques.

L'ensemble de données contient 2,7 000 lignes et 7 colonnes.
Les colonnes incluent:

- Âge (Quantitative)
- Sexe (qualitative binaire)
- IMC (Indice de masse corporelle)
- Enfants (quantitative)
- Fumeur qualitative binaire
- Région (qualitative)
-Frais (quantitative)

# ***Objectif***


Constuire un modele d'apprentissage automatique pour améliorer l’efficacité et la rentabilité des compagnies d’assurance maladie ?
"""

import pandas as pd
import numpy as np
import os
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import make_pipeline

import kagglehub


chemin = kagglehub.dataset_download("harishkumardatalab/medical-insurance-price-prediction")

print("Path to dataset files:", chemin)


for filename in os.listdir(chemin):
    if filename.endswith(".csv"):
        csv_file_path = os.path.join(chemin, filename)
        break


df = pd.read_csv(csv_file_path)
df.head()

"""# **Vérifications des valeurs manquantés**"""

df.info()

df.isnull().sum()

"""# **Vérifications des valeurs aberrantées**"""

fig,axes=plt.subplots(nrows=3,ncols=3,figsize=(40,20))
axes[0][0].plot(df['age'],df['charges'],'o')
axes[0][0].set_ylabel('charges')
axes[0][0].set_xlabel('age')
axes[0][0].set_title('Lien entre age et charges')

axes[0][1].plot(df['children'],df['charges'],'o')
axes[0][1].set_ylabel('charges')
axes[0][1].set_xlabel('children')
axes[0][1].set_title('Lien entre children et charges')

axes[0][2].plot(df['bmi'],df['charges'],'o')
axes[0][2].set_ylabel('charges')
axes[0][2].set_xlabel('bmi')
axes[0][2].set_title('Lien entre bmi et charges')

sns.boxplot(x="charges",data=df,hue="smoker",ax=axes[1][0])
axes[1][0].set_ylabel('charges')
axes[1][0].set_xlabel('smoker')
axes[1][0].set_title('BOXPLOT charges selon smoker')

sns.boxplot(x="charges",data=df,hue="region",ax=axes[1][1])
axes[1][1].set_ylabel('charges')
axes[1][1].set_xlabel('region')
axes[1][1].set_title('BOXPLOT charges selon le region')

sns.boxplot(x="charges",data=df,hue="sex",ax=axes[1][2])
axes[1][2].set_ylabel('charges')
axes[1][2].set_xlabel('sex')
axes[1][2].set_title('BOXPLOT charges selon le sex')


axes[2][0].pie(x=df['smoker'].value_counts(),labels=df['smoker'].value_counts().index,autopct='%1.1f%%')

axes[2][0].set_title('Distribution des clients selon smoker')


axes[2][1].pie(x=df['region'].value_counts(),labels=df['region'].value_counts().index,autopct='%1.1f%%')

axes[2][1].set_title('Distribution des clients selon le region')



axes[2][2].pie(x=df['sex'].value_counts(),labels=df['sex'].value_counts().index,autopct='%1.1f%%')

axes[2][2].set_title('Distribution des clients selon le sex')

plt.show()

"""# ***Statistiques descriptives***"""

statistiques = df.groupby(['sex', 'smoker'])['charges'].describe()

statistiques

df.groupby('region')['charges'].describe()

df['age'].describe()

df['bmi'].describe()

df['children'].describe()

df['charges'].describe()

map={'yes':1,'no':0}
df['smoker']=df['smoker'].map(map).astype(bool)
map_2={'male':1,'female':0}
df['sex']=df['sex'].map(map_2).astype(bool)
map_3={'southwest':'Nord','southeast':'Sud','northwest':'Est','northeast':'Ouest'}
df['region']=df['region'].map(map_3)

import pandas as pd
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_percentage_error
from sklearn.preprocessing import OneHotEncoder, StandardScaler, FunctionTransformer
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import make_pipeline


Y = df['charges']
X = df.drop(['charges'], axis=1)

X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.2, random_state=42)

preprocessor = ColumnTransformer(transformers=[
    ('Variables quantitatives', StandardScaler(), X.select_dtypes(include=['float64', 'int64']).columns),
    ('Variable qualitative', OneHotEncoder(sparse_output=False, handle_unknown='ignore'), X.select_dtypes(include=['object']).columns),
    ('Variables binaires', 'passthrough', X.select_dtypes(include=['bool']).columns)


])






model = make_pipeline(
    preprocessor,
    RandomForestRegressor()
)


param_grid = {
    'randomforestregressor__n_estimators': [50, 100, 200],
    'randomforestregressor__max_depth': [None, 10, 20],
    'randomforestregressor__min_samples_split': [2, 5, 10],
    'randomforestregressor__min_samples_leaf': [1, 2, 4]
}

grid_model = GridSearchCV(model, param_grid=param_grid, cv=5, scoring='neg_mean_squared_error')


grid_model.fit(X_train, y_train)

"""# ***Meilleurs hyperparamètres***"""

print("Meilleurs paramètres :", grid_model.best_params_)

best_model =grid_model.best_estimator_
y_pred = best_model.predict(X_test)

"""# ***Évaluation***"""

rmse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)
mape = mean_absolute_percentage_error(y_test, y_pred)

print(f"RMSE : {rmse}")
print(f"R² : {r2}")
print(f"MAPE : {mape}")

"""# **Analyse des Résidus**"""

from yellowbrick.regressor import ResidualsPlot, prediction_error
resisdu=ResidualsPlot(best_model)
resisdu.fit(X_train,y_train)
resisdu.score(X_test,y_test)
resisdu.show()

from yellowbrick.regressor import prediction_error
error = prediction_error(best_model, X_train, y_train)

error.score(X_test, y_test)
error.show()

"""#**Sauvegarder le modèle**"""

import joblib
modele=best_model
joblib.dump(modele,'modele.pkl')

"""# ***Campagne***"""

campaign=[[24,False,23,2,True,'Nord']]
x_cols=X.columns
campagne=pd.DataFrame(campaign,columns=x_cols)
campagne.to_csv('campagne.csv',index=False)
campagne

loaded_model = joblib.load('modele.pkl')
float(loaded_model.predict(campagne)[0])

"""# ***Déploiement d'un modèle RandomForestRegressor()***"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile application.py
# 
# import streamlit as st
# import joblib
# import pandas as pd
# 
# # Charger le modèle entraîné
# @st.cache_resource
# def load_model():
#     # Charger le modèle avec joblib
#     try:
#         with open("modele.pkl", "rb") as file:
#             model = joblib.load(file)
#         return model
#     except Exception as e:
#         st.error(f"Erreur lors du chargement du modèle : {str(e)}")
#         return None
# 
# model = load_model()
# 
# # Vérifiez si le modèle est valide
# if model and not hasattr(model, "predict"):
#     st.error("Le modèle chargé n'a pas de méthode 'predict'. Vérifiez que vous avez bien enregistré un modèle scikit-learn valide.")
# elif not model:
#     st.error("Le modèle n'a pas pu être chargé correctement. Veuillez vérifier le fichier.")
# 
# # Interface utilisateur
# st.title("Déploiement d'un modèle RandomForestRegressor()")
# 
# # Ajouter une photo illustrative
# st.image("C:/Users/Utilisateur/Desktop/APPLICATION MODELE/image.jpg", caption="Photo", use_column_width=True)
# 
# st.subheader("Simuler vos dépenses médicales")
# 
# # Champs d'entrée utilisateur
# age = st.number_input("Quel âge avez-vous ?", min_value=0, step=1, format="%d")
# sex = st.radio("Quel est votre sexe ?", ["Homme", "Femme"])  # Pas de valeur par défaut
# bmi = st.number_input("Quel est votre IMC (Indice de Masse Corporelle) ?", min_value=0.0, step=0.1, format="%.1f")
# children = st.number_input("Nombre d'enfants", min_value=0, step=1, format="%d")
# smoker = st.radio("Est-ce que vous fumez ?", ["Oui", "Non"])  # Pas de valeur par défaut
# region = st.radio("Quelle est votre région ?", ["Nord", "Sud", "Est", "Ouest"])  # Pas de valeur par défaut
# 
# if st.button("Simulation"):
#     try:
#         # Afficher les données saisies par le client
#         st.subheader("Données saisies par le client :")
#         donne = pd.DataFrame({
#             "Age": [age],
#             "Sexe": [sex],
#             "Indice de Masse Corporelle": [bmi],
#             "Nombre d'enfants": [children],
#             "Fumeur": [smoker],
#             "Région": [region]
#         })
#         st.write(donne)
# 
#         # Encodage des variables qualitatives
#         sex_encoded = False if sex == "Femme" else True  # False pour Femme, True pour Homme
#         smoker_encoded = True if smoker == "Oui" else False  # True pour Oui, False pour Non
# 
#         # Préparer les données pour le modèle
#         input_data = pd.DataFrame({
#             'age': [age],
#             'sex': [sex_encoded],  # Booléen
#             'bmi': [bmi],
#             'children': [children],
#             'smoker': [smoker_encoded],  # Booléen
#             'region': [region]  # Pas d'encodage supplémentaire pour la région
#         })
# 
#         # Prédiction avec le modèle
#         if model:
#             prediction = model.predict(input_data)
#             st.success(f"Les dépenses médicales pour ce client seront : {prediction[0]:.2f} $")
#         else:
#             st.error("Le modèle n'est pas disponible pour effectuer la prédiction.")
#     except Exception as e:
#         st.error(f"Une erreur est survenue : {str(e)}")
#